<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Act II - Layer III - Bullet Hell Nightmare</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      font-family: 'Inter', sans-serif;
      background: #000000; /* Pure black background */
      height: 100vh;
      color: #ffffff;
      position: relative;
      margin: 0;
      padding: 0;
      overflow: hidden;
      cursor: default; /* Show cursor always */
    }

    /* Beautiful white starfield animation - improved and cleaner */
    .background-particles {
      position: fixed;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .star-field::before,
    .star-field::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: gentleTwinkle 4s infinite ease-in-out;
      box-shadow: 
        20px 30px 0 0 rgba(255, 255, 255, 0.8),
        80px 20px 0 0 rgba(255, 255, 255, 0.6),
        140px 50px 0 0 rgba(255, 255, 255, 0.9),
        200px 10px 0 0 rgba(255, 255, 255, 0.7),
        260px 40px 0 0 rgba(255, 255, 255, 0.8),
        320px 60px 0 0 rgba(255, 255, 255, 0.5),
        380px 25px 0 0 rgba(255, 255, 255, 0.9),
        440px 45px 0 0 rgba(255, 255, 255, 0.6),
        500px 15px 0 0 rgba(255, 255, 255, 0.8),
        560px 55px 0 0 rgba(255, 255, 255, 0.7),
        620px 35px 0 0 rgba(255, 255, 255, 0.6),
        680px 65px 0 0 rgba(255, 255, 255, 0.9),
        740px 20px 0 0 rgba(255, 255, 255, 0.5),
        800px 50px 0 0 rgba(255, 255, 255, 0.8),
        860px 30px 0 0 rgba(255, 255, 255, 0.7),
        920px 60px 0 0 rgba(255, 255, 255, 0.6);
    }

    .star-field::after {
      top: 80px;
      left: 40px;
      animation-delay: 2s;
      animation-duration: 6s;
      box-shadow: 
        40px 20px 0 0 rgba(255, 255, 255, 0.7),
        100px 60px 0 0 rgba(255, 255, 255, 0.5),
        160px 10px 0 0 rgba(255, 255, 255, 0.8),
        220px 40px 0 0 rgba(255, 255, 255, 0.6),
        280px 70px 0 0 rgba(255, 255, 255, 0.9),
        340px 25px 0 0 rgba(255, 255, 255, 0.7),
        400px 55px 0 0 rgba(255, 255, 255, 0.5),
        460px 15px 0 0 rgba(255, 255, 255, 0.8),
        520px 45px 0 0 rgba(255, 255, 255, 0.6),
        580px 75px 0 0 rgba(255, 255, 255, 0.9),
        640px 30px 0 0 rgba(255, 255, 255, 0.7),
        700px 50px 0 0 rgba(255, 255, 255, 0.5),
        760px 65px 0 0 rgba(255, 255, 255, 0.8),
        820px 35px 0 0 rgba(255, 255, 255, 0.6),
        880px 55px 0 0 rgba(255, 255, 255, 0.7),
        940px 25px 0 0 rgba(255, 255, 255, 0.9);
    }

    @keyframes gentleTwinkle {
      0%, 100% { 
        opacity: 0.4; 
        transform: scale(0.8); 
      }
      50% { 
        opacity: 1; 
        transform: scale(1.1); 
      }
    }

    /* Improved floating orbs - smoother and more elegant */
    .floating-orbs {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .orb {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      animation: smoothFloat 12s infinite ease-in-out;
      filter: blur(0.5px);
    }

    .orb:nth-child(1) {
      width: 25px;
      height: 25px;
      top: 15%;
      left: 8%;
      animation-delay: 0s;
      animation-duration: 10s;
    }

    .orb:nth-child(2) {
      width: 18px;
      height: 18px;
      top: 65%;
      left: 85%;
      animation-delay: 3s;
      animation-duration: 14s;
    }

    .orb:nth-child(3) {
      width: 30px;
      height: 30px;
      top: 45%;
      left: 75%;
      animation-delay: 6s;
      animation-duration: 12s;
    }

    .orb:nth-child(4) {
      width: 22px;
      height: 22px;
      top: 75%;
      left: 15%;
      animation-delay: 2s;
      animation-duration: 16s;
    }

    .orb:nth-child(5) {
      width: 28px;
      height: 28px;
      top: 25%;
      left: 92%;
      animation-delay: 5s;
      animation-duration: 11s;
    }

    @keyframes smoothFloat {
      0%, 100% { 
        transform: translate(0, 0) scale(1);
        opacity: 0.3;
      }
      25% { 
        transform: translate(-30px, -40px) scale(1.1);
        opacity: 0.6;
      }
      50% { 
        transform: translate(20px, -60px) scale(0.9);
        opacity: 0.8;
      }
      75% { 
        transform: translate(40px, -20px) scale(1.05);
        opacity: 0.5;
      }
    }

    /* Elegant geometric lines - improved movement */
    .geometric-lines {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .line {
      position: absolute;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 255, 255, 0.1), 
        rgba(255, 255, 255, 0.4), 
        rgba(255, 255, 255, 0.1), 
        transparent);
      animation: elegantSlide 8s infinite linear;
      opacity: 0.7;
    }

    .line:nth-child(1) {
      width: 300px;
      height: 1px;
      top: 20%;
      animation-delay: 0s;
    }

    .line:nth-child(2) {
      width: 250px;
      height: 1px;
      top: 55%;
      animation-delay: 3s;
    }

    .line:nth-child(3) {
      width: 350px;
      height: 1px;
      top: 80%;
      animation-delay: 6s;
    }

    @keyframes elegantSlide {
      0% { 
        left: -400px;
        opacity: 0;
      }
      20% { 
        opacity: 0.7;
      }
      80% { 
        opacity: 0.7;
      }
      100% { 
        left: 100%;
        opacity: 0;
      }
    }

    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .header {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 5, 40, 0.8));
      padding: 15px 30px;
      border-radius: 20px;
      border: 3px solid #ff0080;
      box-shadow: 
        0 0 30px rgba(255, 0, 128, 0.6),
        inset 0 0 20px rgba(255, 0, 128, 0.1),
        0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }

    .title {
      font-family: 'Orbitron', monospace;
      font-size: 2.2rem;
      font-weight: 900;
      color: #ff0080;
      text-shadow: 
        0 0 10px #ff0080,
        0 0 20px #ff0080,
        0 0 40px #ff0080,
        2px 2px 4px rgba(0, 0, 0, 0.8);
      margin-bottom: 8px;
      letter-spacing: 3px;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }

    @keyframes titleGlow {
      from { 
        text-shadow: 
          0 0 10px #ff0080,
          0 0 20px #ff0080,
          0 0 40px #ff0080,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      to { 
        text-shadow: 
          0 0 15px #ff0080,
          0 0 30px #ff0080,
          0 0 60px #ff0080,
          0 0 80px #ff4080,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
    }

    .subtitle {
      font-family: 'Orbitron', monospace;
      font-size: 1.1rem;
      color: #00ffff;
      text-shadow: 
        0 0 8px rgba(0, 255, 255, 0.8),
        0 0 16px rgba(0, 255, 255, 0.4);
      animation: subtitlePulse 3s ease-in-out infinite;
    }

    @keyframes subtitlePulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    .game-area {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 30% 20%, rgba(255, 0, 128, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 70% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at center, rgba(128, 0, 255, 0.08) 0%, transparent 70%);
    }

    .player {
      position: absolute;
      width: 24px;
      height: 24px;
      background: #00ffff;
      border-radius: 50%;
      z-index: 50;
      transition: none;
      /* Removed complex animations and effects for performance */
    }

    .bullet {
      position: absolute;
      border-radius: 50%;
      z-index: 10;
      /* Removed glow animation for performance */
    }

    .bullet-small {
      width: 8px;
      height: 8px;
      background: #ff4080;
      /* Removed glow effects for performance */
    }

    .bullet-medium {
      width: 14px;
      height: 14px;
      background: #ff8000;
      /* Removed glow effects for performance */
    }

    .bullet-large {
      width: 20px;
      height: 20px;
      background: #ff0080;
      /* Removed glow effects for performance */
    }

    .bullet-laser {
      width: 6px;
      height: 45px;
      border-radius: 3px;
      background: #ffff00;
      /* Removed glow effects for performance */
    }

    .boss {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
      background: #ff0080;
      border-radius: 25px;
      z-index: 40;
      /* Removed complex animations for performance */
    }

    .ui {
      position: absolute;
      top: 110px;
      left: 15px;
      z-index: 100;
      font-family: 'Orbitron', monospace;
      color: #ffffff;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 5, 40, 0.7));
      padding: 20px;
      border-radius: 15px;
      border: 2px solid #00ffff;
      box-shadow: 
        0 0 25px rgba(0, 255, 255, 0.3),
        inset 0 0 15px rgba(0, 255, 255, 0.1),
        0 8px 32px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
    }

    .health-bar {
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00ffff;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
      transition: width 0.3s ease;
      border-radius: 8px;
    }

    .boss-health-bar {
      width: 350px;
      height: 18px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff0080;
      border-radius: 12px;
      overflow: hidden;
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 100;
      box-shadow: 
        0 0 20px rgba(255, 0, 128, 0.4),
        inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .boss-health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0080, #ff4080 30%, #8000ff 70%, #ff0080);
      transition: width 0.3s ease;
      border-radius: 8px;
      box-shadow: 
        0 0 15px rgba(255, 0, 128, 0.6),
        inset 0 0 8px rgba(255, 255, 255, 0.3);
      animation: healthPulse 2s ease-in-out infinite;
    }

    @keyframes healthPulse {
      0%, 100% { filter: brightness(1) saturate(1); }
      50% { filter: brightness(1.2) saturate(1.3); }
    }

    .score {
      font-size: 1.2rem;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
      margin-bottom: 5px;
    }

    .lives {
      font-size: 1rem;
      color: #ff4000;
      text-shadow: 0 0 5px #ff4000;
    }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #ff0080;
      padding: 40px;
      border-radius: 20px;
      border: 3px solid #ff0080;
      text-align: center;
      z-index: 1000;
      font-family: 'Orbitron', monospace;
      box-shadow: 0 0 50px rgba(255, 0, 128, 0.8);
      display: none;
    }

    .game-over h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #ff0080;
    }

    .game-over p {
      font-size: 1.2rem;
      margin-bottom: 30px;
    }

    .restart-btn {
      background: linear-gradient(45deg, #ff0080, #8000ff);
      border: 2px solid #ffffff;
      color: #ffffff;
      padding: 15px 30px;
      font-family: 'Orbitron', monospace;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .restart-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 0, 128, 0.8);
    }

    .victory {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: #00ff00;
      padding: 40px;
      border-radius: 20px;
      border: 3px solid #00ff00;
      text-align: center;
      z-index: 1000;
      font-family: 'Orbitron', monospace;
      box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
      display: none;
    }

    .victory h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #00ff00;
    }

    .next-btn {
      background: linear-gradient(45deg, #00ff00, #00ffff);
      border: 2px solid #ffffff;
      color: #000000;
      padding: 15px 30px;
      font-family: 'Orbitron', monospace;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .next-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }

    .back-btn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: rgba(255, 0, 128, 0.2);
      border: 2px solid rgba(255, 0, 128, 0.6);
      color: #ff0080;
      padding: 0.5rem 1rem;
      text-decoration: none;
      border-radius: 8px;
      font-family: 'Orbitron', monospace;
      font-size: 0.9rem;
      z-index: 1000;
      transition: all 0.3s ease;
    }

    .back-btn:hover {
      background: rgba(255, 0, 128, 0.4);
      border-color: #ff0080;
      transform: translateY(-2px);
    }

    /* Particle effects */
    .explosion {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #ffff00, #ff4000, transparent);
      animation: explode 0.5s ease-out forwards;
      z-index: 30;
    }

    @keyframes explode {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(3); opacity: 0; }
    }

    .warning {
      position: absolute;
      color: #ff0000;
      font-family: 'Orbitron', monospace;
      font-size: 2rem;
      font-weight: 900;
      text-shadow: 0 0 20px #ff0000;
      animation: warningBlink 0.5s infinite;
      z-index: 60;
    }

    @keyframes warningBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .difficulty-indicator {
      position: absolute;
      bottom: 25px;
      right: 25px;
      font-family: 'Orbitron', monospace;
      color: #ff8000;
      font-size: 1.6rem;
      font-weight: 900;
      text-shadow: 
        0 0 20px #ff8000,
        0 0 40px #ff8000,
        2px 2px 4px rgba(0, 0, 0, 0.8);
      z-index: 100;
      animation: pulseOrange 1.5s infinite;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(40, 20, 0, 0.5));
      padding: 15px 25px;
      border-radius: 15px;
      border: 2px solid #ff8000;
      backdrop-filter: blur(5px);
    }

    @keyframes pulseOrange {
      0%, 100% { 
        transform: scale(1);
        text-shadow: 
          0 0 20px #ff8000,
          0 0 40px #ff8000,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      50% { 
        transform: scale(1.05);
        text-shadow: 
          0 0 30px #ff8000,
          0 0 60px #ff8000,
          0 0 80px #ffb040,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
    }

    #konami-activated {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-size: 2rem;
      color: #00ff00;
      text-shadow: 0 0 20px #00ff00;
      z-index: 2000;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid #00ff00;
    }

    .player.invincible {
      animation: blink 0.1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
  </style>
</head>
<body>
  <!-- Beautiful white background animations -->
  <div class="background-particles">
    <div class="star-field"></div>
    <div class="floating-orbs">
      <div class="orb"></div>
      <div class="orb"></div>
      <div class="orb"></div>
      <div class="orb"></div>
      <div class="orb"></div>
    </div>
    <div class="geometric-lines">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
  </div>

  <!-- Back button -->
  <a href="layer-2-2.html" class="back-btn">← Previous Layer</a>
  
  <div class="game-container">
    <div class="header">
      <h1 class="title">BULLET HELL CHALLENGE</h1>
      <p class="subtitle">Act II - Layer III - CHALLENGING MODE</p>
    </div>

    <!-- Background Music -->
    <audio id="backgroundMusic" loop>
      <source src="../assets/touhou.mp3" type="audio/mpeg">
      Your browser does not support the audio element.
    </audio>

    <div class="game-area" id="gameArea">
      <div class="player" id="player"></div>
      <div class="boss" id="boss"></div>
    </div>

    <div class="ui">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="lives" style="color: #ff0000; font-weight: bold;">ONE HIT = DEATH</div>
      <div class="health-bar" style="display: none;">
        <div class="health-fill" id="healthFill" style="width: 100%"></div>
      </div>
    </div>

    <div class="boss-health-bar">
      <div class="boss-health-fill" id="bossHealthFill" style="width: 100%"></div>
    </div>

    <div class="difficulty-indicator">
      CHALLENGING MODE - ONE HIT DEATH
    </div>

    <div id="konami-activated" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Orbitron', monospace; font-size: 2rem; color: #00ff00; text-shadow: 0 0 20px #00ff00; z-index: 2000; background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 10px; border: 2px solid #00ff00;">
      KONAMI CODE ACTIVATED!
    </div>
  </div>

  <!-- Game Over Screen -->
  <div class="game-over" id="gameOver">
    <h2>INSTANT DEATH!</h2>
    <p>You couldn't survive the nightmare bullet hell!</p>
    <p>Even one bullet is lethal in this mode!</p>
    <p>Score: <span id="finalScore">0</span></p>
    <button class="restart-btn" onclick="restartGame()">Try Again</button>
  </div>

  <!-- Victory Screen -->
  <div class="victory" id="victory">
    <h2>LEGENDARY ACHIEVEMENT!</h2>
    <p>You reached 25,000 points in the bullet hell nightmare!</p>
    <p>Final Score: <span id="victoryScore">0</span></p>
    <button class="next-btn" onclick="nextLayer()">Continue to Next Layer</button>
  </div>

  <script>
    // Game state - heavily optimized for performance
    let gameState = {
      player: { x: 400, y: 500, health: 1, maxHealth: 1, lives: 1, invincible: false, invincibleTimer: 0 }, // One hit death
      boss: { x: 400, y: 100, health: 1000, maxHealth: 1000, phase: 1 },
      bullets: [],
      bulletPool: [], // Object pool for performance
      maxBullets: 150, // Reduced from 300 for better performance
      score: 0,
      gameRunning: true,
      keys: {},
      lastTime: 0,
      lastUIUpdate: 0,
      uiUpdateInterval: 200, // Reduced UI update frequency for performance
      difficulty: 3,
      bulletSpeed: 12, // Increased bullet speed significantly
      bulletSpawnRate: 0.12, // Increased spawn rate for more intensity
      patternIndex: 0,
      phaseTimer: 0,
      frameCount: 0, // For performance monitoring
      konamiCode: false
    };

    // Konami Code sequence
    const konamiSequence = ['arrowup', 'arrowup', 'arrowdown', 'arrowdown', 'arrowleft', 'arrowright', 'arrowleft', 'arrowright', 'b', 'a'];
    let konamiProgress = 0;

    // Bullet patterns with more variety
    const bulletPatterns = [
      'spiral', 'wall', 'cross', 'random', 'laser', 'flower', 'maze', 'chaos',
      'donut', 'wave', 'spinner', 'diamond', 'star', 'vortex', 'rain', 'grid'
    ];

    // Initialize game
    function initGame() {
      const player = document.getElementById('player');
      const boss = document.getElementById('boss');
      
      player.style.left = gameState.player.x + 'px';
      player.style.top = gameState.player.y + 'px';
      boss.style.left = gameState.boss.x + 'px';
      boss.style.top = gameState.boss.y + 'px';
      
      updateUI();
      
      // Start background music
      const music = document.getElementById('backgroundMusic');
      music.volume = 0.4;
      music.play().catch(e => console.log('Music blocked:', e));
      
      // Add event listeners
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      // Removed mouse movement controls
      
      // Start game loop
      requestAnimationFrame(gameLoop);
    }

    function handleKeyDown(e) {
      gameState.keys[e.key.toLowerCase()] = true;
      
      // Start music on first keypress
      const music = document.getElementById('backgroundMusic');
      if (music.paused) {
        music.play().catch(e => console.log('Could not start music:', e));
      }

      // Check for Konami Code
      if (e.key.toLowerCase() === konamiSequence[konamiProgress]) {
        konamiProgress++;
        if (konamiProgress === konamiSequence.length) {
          activateKonamiCode();
          konamiProgress = 0; // Reset for potential re-activation
        }
      } else {
        konamiProgress = 0;
      }
    }

    function handleKeyUp(e) {
      gameState.keys[e.key.toLowerCase()] = false;
    }

    function activateKonamiCode() {
      if (gameState.konamiCode) return; // Already activated

      gameState.konamiCode = true;
      gameState.player.lives = 3; // Give player lives
      gameState.bulletSpeed = 6; // Reduce bullet speed
      gameState.bulletSpawnRate = 0.06; // Reduce spawn rate

      // Update UI to show changes
      document.querySelector('.difficulty-indicator').textContent = 'EASY MODE - KONAMI ACTIVATED';
      document.querySelector('.difficulty-indicator').style.color = '#00ff00';
      document.querySelector('.difficulty-indicator').style.borderColor = '#00ff00';
      document.querySelector('.lives').textContent = `Lives: ${gameState.player.lives}`;
      document.querySelector('.lives').style.color = '#00ff00';
      document.querySelector('.health-bar').style.display = 'none'; // Hide health bar

      // Show activation message
      const konamiMessage = document.getElementById('konami-activated');
      konamiMessage.style.display = 'block';
      setTimeout(() => {
        konamiMessage.style.display = 'none';
      }, 3000);
    }

    // Removed mouse movement function - only keyboard controls now

    function gameLoop(currentTime) {
      if (!gameState.gameRunning) return;
      
      const deltaTime = currentTime - gameState.lastTime;
      gameState.lastTime = currentTime;
      
      updatePlayer(deltaTime);
      updateBoss();
      spawnBullets();
      updateBullets();
      checkCollisions();
      
      // Only update UI if not in Konami mode, otherwise it's handled separately
      if (!gameState.konamiCode) {
        updateUI();
      } else {
        document.getElementById('score').textContent = gameState.score;
      }
      
      gameState.phaseTimer += deltaTime;
      
      // Change bullet pattern every 2 seconds for more intensity
      if (gameState.phaseTimer > 2000) {
        gameState.patternIndex = (gameState.patternIndex + 1) % bulletPatterns.length;
        gameState.phaseTimer = 0;
        showWarning();
      }
      
      requestAnimationFrame(gameLoop);
    }

    function updatePlayer(deltaTime) {
      const speed = 8; // Increased player speed to compensate for faster bullets
      const player = document.getElementById('player');

      // Handle invincibility frames
      if (gameState.player.invincible) {
        gameState.player.invincibleTimer -= deltaTime;
        if (gameState.player.invincibleTimer <= 0) {
          gameState.player.invincible = false;
          player.classList.remove('invincible');
        }
      }
      
      // WASD movement
      if (gameState.keys['w'] || gameState.keys['arrowup']) {
        gameState.player.y = Math.max(10, gameState.player.y - speed);
      }
      if (gameState.keys['s'] || gameState.keys['arrowdown']) {
        gameState.player.y = Math.min(window.innerHeight - 30, gameState.player.y + speed);
      }
      if (gameState.keys['a'] || gameState.keys['arrowleft']) {
        gameState.player.x = Math.max(10, gameState.player.x - speed);
      }
      if (gameState.keys['d'] || gameState.keys['arrowright']) {
        gameState.player.x = Math.min(window.innerWidth - 30, gameState.player.x + speed);
      }
      
      player.style.left = gameState.player.x + 'px';
      player.style.top = gameState.player.y + 'px';
    }

    function updateHealthBar() {
      const healthFill = document.getElementById('healthFill');
      const healthPercentage = (gameState.player.health / gameState.player.maxHealth) * 100;
      healthFill.style.width = `${healthPercentage}%`;
    }

    function updateBoss() {
      // Boss movement pattern
      const time = Date.now() * 0.001;
      gameState.boss.x = 400 + Math.sin(time * 0.5) * 200;
      
      const boss = document.getElementById('boss');
      boss.style.left = gameState.boss.x + 'px';
    }

    function spawnBullets() {
      if (Math.random() < gameState.bulletSpawnRate) {
        const pattern = bulletPatterns[gameState.patternIndex];
        createBulletPattern(pattern);
      }
    }

    function createBulletPattern(pattern) {
      const centerX = gameState.boss.x + 40;
      const centerY = gameState.boss.y + 40;
      
      switch (pattern) {
        case 'spiral':
          createSpiralPattern(centerX, centerY);
          break;
        case 'wall':
          createWallPattern();
          break;
        case 'cross':
          createCrossPattern(centerX, centerY);
          break;
        case 'random':
          createRandomPattern(centerX, centerY);
          break;
        case 'laser':
          createLaserPattern(centerX, centerY);
          break;
        case 'flower':
          createFlowerPattern(centerX, centerY);
          break;
        case 'maze':
          createMazePattern();
          break;
        case 'chaos':
          createChaosPattern();
          break;
        case 'donut':
          createDonutPattern(centerX, centerY);
          break;
        case 'wave':
          createWavePattern();
          break;
        case 'spinner':
          createSpinnerPattern(centerX, centerY);
          break;
        case 'diamond':
          createDiamondPattern(centerX, centerY);
          break;
        case 'star':
          createStarPattern(centerX, centerY);
          break;
        case 'vortex':
          createVortexPattern(centerX, centerY);
          break;
        case 'rain':
          createRainPattern();
          break;
        case 'grid':
          createGridPattern();
          break;
      }
    }

    function createSpiralPattern(x, y) {
      const time = Date.now() * 0.005;
      // Fast spiral pattern
      for (let i = 0; i < 12; i++) { // Increased from 8
        const angle = (i * Math.PI * 2 / 12) + time;
        createBullet(x, y, Math.cos(angle) * 8, Math.sin(angle) * 8, 'small'); // Faster bullets
      }
    }

    function createWallPattern() {
      // Fast wall pattern
      for (let i = 0; i < 16; i++) { // Increased from 12
        const x = (window.innerWidth / 15) * i;
        createBullet(x, 0, 0, 8, 'medium'); // Much faster downward
      }
    }

    function createCrossPattern(x, y) {
      const directions = [
        [1, 0], [-1, 0], [0, 1], [0, -1],
        [0.7, 0.7], [-0.7, 0.7], [0.7, -0.7], [-0.7, -0.7] // Added diagonal directions
      ];
      
      // Fast cross pattern
      directions.forEach(([dx, dy]) => {
        for (let i = 0; i < 3; i++) { // Increased from 2
          createBullet(x, y, dx * (6 + i * 2), dy * (6 + i * 2), 'large'); // Much faster
        }
      });
    }

    function createRandomPattern(x, y) {
      // Fast random pattern
      for (let i = 0; i < 15; i++) { // Increased from 10
        const angle = Math.random() * Math.PI * 2;
        const speed = 4 + Math.random() * 6; // Faster random speed
        createBullet(
          x + (Math.random() - 0.5) * 80,
          y + (Math.random() - 0.5) * 80,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          'small'
        );
      }
    }

    function createLaserPattern(x, y) {
      // Fast laser pattern
      for (let i = 0; i < 8; i++) { // Increased from 6
        const angle = (Math.PI * 2 / 8) * i;
        createBullet(x, y, Math.cos(angle) * 10, Math.sin(angle) * 10, 'laser'); // Much faster
      }
    }

    function createFlowerPattern(x, y) {
      const time = Date.now() * 0.003;
      // Fast flower pattern
      for (let i = 0; i < 20; i++) { // Increased from 16
        const angle = (i * Math.PI * 2 / 20) + time;
        const radius = Math.sin(time + i * 0.5) * 2 + 5; // Faster radius
        createBullet(x, y, Math.cos(angle) * radius, Math.sin(angle) * radius, 'small');
      }
    }

    function createMazePattern() {
      // Fast maze pattern
      for (let i = 0; i < 12; i++) { // Increased from 8
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * 150;
        createBullet(x, y, (Math.random() - 0.5) * 6, 6 + Math.random() * 4, 'medium'); // Much faster
      }
    }

    function createChaosPattern() {
      // Intense chaos - combine multiple fast patterns
      createSpiralPattern(gameState.boss.x + 40, gameState.boss.y + 40);
      createRandomPattern(gameState.boss.x + 40, gameState.boss.y + 40);
      
      if (Math.random() > 0.4) { // More frequent
        createWallPattern();
      }
    }

    // NEW PATTERNS - FASTER AND MORE INTENSE
    function createDonutPattern(x, y) {
      const time = Date.now() * 0.004;
      // Fast donut pattern
      for (let ring = 1; ring <= 3; ring++) { // Added third ring
        for (let i = 0; i < 10; i++) { // Increased from 8
          const angle = (i * Math.PI * 2 / 10) + time * ring;
          const radius = ring * 3; // Faster expansion
          createBullet(x, y, Math.cos(angle) * radius, Math.sin(angle) * radius, 'small');
        }
      }
    }

    function createWavePattern() {
      const time = Date.now() * 0.003;
      // Fast wave pattern
      for (let i = 0; i < 12; i++) { // Increased from 8
        const x = (window.innerWidth / 11) * i;
        const waveOffset = Math.sin(time + i * 0.3) * 80; // Bigger wave
        createBullet(x + waveOffset, 0, 0, 7, 'medium'); // Much faster
      }
    }

    function createSpinnerPattern(x, y) {
      const time = Date.now() * 0.008;
      // Fast spinner pattern
      for (let arm = 0; arm < 4; arm++) { // Back to 4 arms
        const baseAngle = (Math.PI * 2 / 4) * arm + time;
        for (let i = 1; i <= 5; i++) { // Increased from 3
          createBullet(
            x + Math.cos(baseAngle) * i * 20,
            y + Math.sin(baseAngle) * i * 20,
            Math.cos(baseAngle) * 6, // Much faster
            Math.sin(baseAngle) * 6,
            'small'
          );
        }
      }
    }

    function createDiamondPattern(x, y) {
      // Fast diamond pattern
      const directions = [
        [1, 1], [-1, 1], [1, -1], [-1, -1]
      ];
      
      directions.forEach(([dx, dy], index) => {
        for (let i = 1; i <= 5; i++) { // Increased from 3
          createBullet(x, y, dx * i * 1.5, dy * i * 1.5, 'medium'); // Much faster
        }
      });
    }

    function createStarPattern(x, y) {
      const time = Date.now() * 0.002;
      // Fast star pattern
      for (let point = 0; point < 5; point++) {
        const angle = (Math.PI * 2 / 5) * point + time;
        for (let i = 1; i <= 6; i++) { // Increased from 4
          createBullet(x, y, Math.cos(angle) * i * 1.2, Math.sin(angle) * i * 1.2, 'small'); // Faster
        }
      }
    }

    function createVortexPattern(x, y) {
      const time = Date.now() * 0.006;
      // Fast vortex pattern
      for (let i = 0; i < 15; i++) { // Increased from 10
        const angle = (i * Math.PI * 2 / 15) + time;
        const radius = Math.sin(time * 2 + i * 0.5) * 4 + 6; // Faster and bigger
        createBullet(x, y, Math.cos(angle) * radius, Math.sin(angle) * radius, 'small');
      }
    }

    function createRainPattern() {
      // Fast rain pattern
      for (let i = 0; i < 10; i++) { // Increased from 6
        const x = Math.random() * window.innerWidth;
        createBullet(x, 0, (Math.random() - 0.5) * 3, 6 + Math.random() * 4, 'small'); // Much faster
      }
    }

    function createGridPattern() {
      // Fast grid pattern
      for (let row = 0; row < 3; row++) { // Back to 3 rows
        for (let col = 0; col < 8; col++) { // Increased from 5
          const x = (window.innerWidth / 8) * col + (window.innerWidth / 16);
          const y = row * 80;
          createBullet(x, y, 0, 8, 'medium'); // Much faster
        }
      }
    }

    function createBullet(x, y, dx, dy, type) {
      // Performance optimization: limit max bullets
      if (gameState.bullets.length >= gameState.maxBullets) {
        return;
      }
      
      let bullet;
      let bulletElement;
      
      // Try to reuse from pool for performance
      if (gameState.bulletPool.length > 0) {
        const pooledBullet = gameState.bulletPool.pop();
        bullet = pooledBullet.bullet;
        bulletElement = pooledBullet.element;
        bulletElement.className = `bullet bullet-${type}`;
      } else {
        bulletElement = document.createElement('div');
        bulletElement.className = `bullet bullet-${type}`;
        // Use transform instead of left/top for better performance
        bulletElement.style.position = 'absolute';
        bulletElement.style.left = '0px';
        bulletElement.style.top = '0px';
        document.getElementById('gameArea').appendChild(bulletElement);
        bullet = {
          element: bulletElement,
          x: 0,
          y: 0,
          dx: 0,
          dy: 0,
          type: ''
        };
      }
      
      // Set bullet properties
      bullet.x = x;
      bullet.y = y;
      bullet.dx = dx;
      bullet.dy = dy;
      bullet.type = type;
      
      let size;
      switch (type) {
        case 'small': size = 8; break;
        case 'medium': size = 14; break;
        case 'large': size = 20; break;
        case 'laser': size = 45; break; // Height of the laser
        default: size = 8;
      }
      bullet.size = size;

      // Use transform for better performance
      bulletElement.style.transform = `translate(${x}px, ${y}px)`;
      bulletElement.style.display = 'block';
      
      gameState.bullets.push(bullet);
    }

    function updateBullets() {
      // High-speed bullet updates every frame
      gameState.frameCount++;
      
      const bulletsToRemove = [];
      
      for (let i = 0; i < gameState.bullets.length; i++) {
        const bullet = gameState.bullets[i];
        if (!bullet) continue;
        
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        
        // Check if bullet is off screen
        if (bullet.x < -50 || bullet.x > window.innerWidth + 50 || 
            bullet.y < -50 || bullet.y > window.innerHeight + 50) {
          bulletsToRemove.push(i);
          // Return to pool for reuse
          bullet.element.style.display = 'none';
          if (gameState.bulletPool.length < 100) { // Limit pool size
            gameState.bulletPool.push({ bullet: bullet, element: bullet.element });
          }
        } else {
          // Update position using transform for better performance
          bullet.element.style.transform = `translate(${bullet.x}px, ${bullet.y}px)`;
        }
      }
      
      // Remove bullets from array (in reverse order to maintain indices)
      for (let i = bulletsToRemove.length - 1; i >= 0; i--) {
        gameState.bullets.splice(bulletsToRemove[i], 1);
      }
    }

    function checkCollisions() {
      if (gameState.player.invincible) return; // Player is invincible

      const player = document.getElementById('player');
      const playerRect = { x: gameState.player.x, y: gameState.player.y, width: 24, height: 24 };

      for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const b = gameState.bullets[i];
        const bulletRect = { x: b.x, y: b.y, width: b.size, height: b.size };

        if (isColliding(playerRect, bulletRect)) {
          if (gameState.konamiCode) {
            gameState.player.lives--;
            document.querySelector('.lives').textContent = `Lives: ${gameState.player.lives}`;
            if (gameState.player.lives <= 0) {
              gameOver();
            } else {
              // Grant 1 second of invincibility
              gameState.player.invincible = true;
              gameState.player.invincibleTimer = 1000;
              player.classList.add('invincible');
            }
          } else {
            gameOver(); // Original one-hit death
          }
          
          createExplosion(b.x, b.y);
          removeBullet(i);
          return; // Only one collision per frame
        }
      }
    }

    function isColliding(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    function removeBullet(index) {
      if (index >= 0 && index < gameState.bullets.length) {
        const bullet = gameState.bullets[index];
        if (bullet && bullet.element) {
          bullet.element.style.display = 'none';
          // Return to pool for reuse
          if (gameState.bulletPool.length < 100) {
            gameState.bulletPool.push({ bullet: bullet, element: bullet.element });
          }
        }
        gameState.bullets.splice(index, 1);
      }
    }

    function takeDamage(damage) {
      // Instant death on any hit
      gameOver();
    }

    function createExplosion(x, y) {
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = x + 'px';
      explosion.style.top = y + 'px';
      document.getElementById('gameArea').appendChild(explosion);
      
      setTimeout(() => explosion.remove(), 500);
    }

    function showWarning() {
      const warning = document.createElement('div');
      warning.className = 'warning';
      warning.textContent = 'NEW PATTERN!';
      warning.style.left = '50%';
      warning.style.top = '50%';
      warning.style.transform = 'translate(-50%, -50%)';
      warning.style.fontSize = '2.5rem';
      document.getElementById('gameArea').appendChild(warning);
      
      // Removed orange flash effect to fix orange flashes
      setTimeout(() => warning.remove(), 1500);
    }

    function updateUI() {
      // Throttle UI updates for performance
      const currentTime = Date.now();
      if (currentTime - gameState.lastUIUpdate < gameState.uiUpdateInterval) {
        return;
      }
      gameState.lastUIUpdate = currentTime;
      
      document.getElementById('score').textContent = gameState.score;
      
      // No health bar or lives to update in one-hit mode
      
      const bossHealthPercent = (gameState.boss.health / gameState.boss.maxHealth) * 100;
      document.getElementById('bossHealthFill').style.width = bossHealthPercent + '%';
      
      // Increase score over time (faster for extreme difficulty)
      gameState.score += 5; // 5x faster score gain
      
      // Check for victory at 5,000 points
      if (gameState.score >= 5000) {
        victory();
        return;
      }
      
      // Boss takes damage over time (slightly faster)
      if (gameState.score % 50 === 0) {
        gameState.boss.health -= 10;
      }
    }

    function gameOver() {
      gameState.gameRunning = false;
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('gameOver').style.display = 'block';
      
      // Stop music
      document.getElementById('backgroundMusic').pause();
    }

    function victory() {
      gameState.gameRunning = false;
      document.getElementById('victoryScore').textContent = gameState.score;
      document.getElementById('victory').style.display = 'block';
      
      // Stop music
      document.getElementById('backgroundMusic').pause();
    }

    function restartGame() {
      // Reset game state completely
      gameState = {
        player: { x: 400, y: 500, health: 1, maxHealth: 1, lives: 1, invincible: false, invincibleTimer: 0 },
        boss: { x: 400, y: 100, health: 1000, maxHealth: 1000, phase: 1 },
        bullets: [],
        bulletPool: [],
        maxBullets: 150,
        score: 0,
        gameRunning: true,
        keys: {},
        lastTime: 0,
        lastUIUpdate: 0,
        uiUpdateInterval: 200,
        difficulty: 3,
        bulletSpeed: 12,
        bulletSpawnRate: 0.12,
        patternIndex: 0,
        phaseTimer: 0,
        frameCount: 0,
        konamiCode: false // Reset Konami code status
      };

      // Reset UI elements
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('victory').style.display = 'none';
      document.querySelector('.difficulty-indicator').textContent = 'CHALLENGING MODE - ONE HIT DEATH';
      document.querySelector('.difficulty-indicator').style.color = '#ff8000';
      document.querySelector('.difficulty-indicator').style.borderColor = '#ff8000';
      document.querySelector('.lives').textContent = 'ONE HIT = DEATH';
      document.querySelector('.lives').style.color = '#ff0000';
      document.querySelector('.health-bar').style.display = 'none';
      document.getElementById('player').classList.remove('invincible');


      // Remove all bullets from DOM
      const gameArea = document.getElementById('gameArea');
      const bullets = gameArea.getElementsByClassName('bullet');
      while (bullets.length > 0) {
        bullets[0].parentNode.removeChild(bullets[0]);
      }

      // Reset player position
      const player = document.getElementById('player');
      player.style.left = gameState.player.x + 'px';
      player.style.top = gameState.player.y + 'px';

      // Restart music
      const music = document.getElementById('backgroundMusic');
      music.currentTime = 0;
      music.play().catch(e => console.log('Music restart failed:', e));

      // Restart game loop
      gameState.lastTime = 0;
      requestAnimationFrame(gameLoop);
    }

    function nextLayer() {
      // Redirect to next layer
      window.location.href = 'layer-2-4.html';
    }

    // Start the game
    initGame();

    console.log('%c🎯 OPTIMIZED BULLET HELL INITIALIZED', 'color: #ff0080; font-size: 16px; font-weight: bold;');
    console.log('%c🔥 ONE HIT DEATH MODE ENGAGED', 'color: #ff0000; font-size: 12px;');
    console.log('%c💥 PERFORMANCE OPTIMIZED + 16 PATTERNS', 'color: #ffff00; font-size: 12px;');
    console.log('%c🏆 VICTORY AT 25,000 POINTS', 'color: #00ff00; font-size: 12px;');
    console.log('%c⚡ HEAVILY PERFORMANCE OPTIMIZED', 'color: #00ffff; font-size: 12px;');
    console.log('%c🚀 60FPS TARGET WITH REDUCED EFFECTS', 'color: #ffaa00; font-size: 12px;');
  </script>
</body>
</html>
